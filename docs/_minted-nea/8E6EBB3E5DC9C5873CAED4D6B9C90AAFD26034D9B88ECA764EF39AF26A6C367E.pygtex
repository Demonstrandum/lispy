\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{} Get a our stream of tokens by calling the lexer}
\PYG{n}{stream} \PYG{p}{:} \PYG{n+no}{TokenStream} \PYG{o}{=} \PYG{n+no}{Lexer}\PYG{o}{::}\PYG{n}{lex} \PYG{n+no}{PROGRAM\PYGZus{}STRING}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{} Define various AST datatypes}
\PYG{n+no}{DataType} \PYG{n+no}{Tree} \PYG{o}{=\PYGZgt{}}
  \PYG{n+nb}{self}\PYG{o}{.}\PYG{n}{children} \PYG{o}{=} \PYG{o}{[]}

\PYG{n+no}{DataType} \PYG{n+no}{Call} \PYG{p}{(}\PYG{n}{values}\PYG{p}{)} \PYG{o}{=\PYGZgt{}}
  \PYG{n+nb}{self}\PYG{o}{.}\PYG{n}{values} \PYG{o}{=} \PYG{n}{values}
  \PYG{n}{get} \PYG{n+nb}{self}\PYG{o}{.}\PYG{n}{operator} \PYG{o}{=\PYGZgt{}}
    \PYG{k}{return} \PYG{n}{head} \PYG{p}{(}\PYG{n+nb}{self}\PYG{o}{.}\PYG{n}{values}\PYG{p}{)}
  \PYG{n}{get} \PYG{n+nb}{self}\PYG{o}{.}\PYG{n}{operands} \PYG{o}{=\PYGZgt{}}
    \PYG{k}{return} \PYG{n}{tail} \PYG{p}{(}\PYG{n+nb}{self}\PYG{o}{.}\PYG{n}{values}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{} Generalised datatype for an atomic AST datum}
\PYG{n+no}{Abstract} \PYG{n+no}{DataType} \PYG{n+no}{Atomic} \PYG{p}{(}\PYG{n}{value}\PYG{p}{)} \PYG{o}{=\PYGZgt{}}
  \PYG{n+nb}{self}\PYG{o}{.}\PYG{n}{value} \PYG{o}{=} \PYG{n}{value}

\PYG{n+no}{DataType} \PYG{n+no}{Numeric} \PYG{n}{inherits} \PYG{n+no}{Atomic}  \PYG{c+c1}{\PYGZsh{} Atomic types represent a single datum.}
\PYG{n+no}{DataType} \PYG{n+no}{Symbol}  \PYG{n}{inherits} \PYG{n+no}{Atomic}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{} Actually implement the parser}
\PYG{n}{parse} \PYG{o}{::} \PYG{n+no}{TokenStream} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+no}{Tree}  \PYG{c+c1}{\PYGZsh{} (Type annotation)}
\PYG{n}{parse} \PYG{p}{(}\PYG{n}{stream}\PYG{p}{)} \PYG{o}{=\PYGZgt{}}
  \PYG{n}{tree} \PYG{o}{=} \PYG{k+kp}{new} \PYG{n+no}{Tree} \PYG{c+c1}{\PYGZsh{} Create an empty tree\PYGZhy{}root}
  \PYG{k}{until} \PYG{n}{empty?} \PYG{n}{stream} \PYG{o}{=\PYGZgt{}}
    \PYG{n}{tree}\PYG{o}{.}\PYG{n}{children}\PYG{o}{.}\PYG{n}{push} \PYG{p}{(}\PYG{n}{atomic} \PYG{p}{(}\PYG{n}{stream}\PYG{p}{))} \PYG{c+c1}{\PYGZsh{} Deals with parsing individual datum}
    \PYG{n}{stream}\PYG{o}{.}\PYG{n}{shift} \PYG{c+c1}{\PYGZsh{} Now shift off of the TokenStream stack}
  \PYG{k}{return} \PYG{n}{tree} \PYG{c+c1}{\PYGZsh{} Return the super\PYGZhy{}tree we\PYGZsq{}ve built up.}

\PYG{n}{atomic} \PYG{o}{::} \PYG{n+no}{TokenStream} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{p}{(}\PYG{n+no}{Call} \PYG{o}{|} \PYG{n+no}{Atomic}\PYG{p}{)}
\PYG{n}{atomic} \PYG{p}{(}\PYG{n}{stream}\PYG{p}{)} \PYG{o}{=\PYGZgt{}}
  \PYG{n}{condition} \PYG{k}{if} \PYG{o}{=\PYGZgt{}}
    \PYG{o}{|} \PYG{p}{(}\PYG{n}{stream}\PYG{o}{[}\PYG{l+m+mi}{0}\PYG{o}{].}\PYG{n}{type} \PYG{n}{is} \PYG{n+no}{L\PYGZus{}PAREN}\PYG{p}{)} \PYG{o}{=\PYGZgt{}}
        \PYG{n}{call} \PYG{o}{=} \PYG{k+kp}{new} \PYG{n+no}{Call} \PYG{o}{[]}  \PYG{c+c1}{\PYGZsh{} An open left\PYGZhy{}parentheses means a function call.}
        \PYG{k}{until} \PYG{n}{stream}\PYG{o}{[}\PYG{l+m+mi}{0}\PYG{o}{]} \PYG{n}{is} \PYG{n+no}{R\PYGZus{}PAREN} \PYG{o}{=\PYGZgt{}} \PYG{c+c1}{\PYGZsh{} Serch for a maching right\PYGZhy{}parentheses.}
          \PYG{n}{stream}\PYG{o}{.}\PYG{n}{shift} \PYG{c+c1}{\PYGZsh{} shift off L\PYGZus{}PAREN from stack (initially).}
          \PYG{n}{call}\PYG{o}{.}\PYG{n}{values}\PYG{o}{.}\PYG{n}{push} \PYG{p}{(}\PYG{n}{atomic} \PYG{p}{(}\PYG{n}{stream}\PYG{p}{))}   \PYG{c+c1}{\PYGZsh{} Push and recursively call}
        \PYG{n}{stream}\PYG{o}{.}\PYG{n}{shift} \PYG{c+c1}{\PYGZsh{} Shift the R\PYGZus{}PAREN off   \PYGZsh{} atomic on shifted stack.}
        \PYG{k}{return} \PYG{n}{call}
    \PYG{o}{|} \PYG{p}{(}\PYG{n}{stream}\PYG{o}{[}\PYG{l+m+mi}{0}\PYG{o}{].}\PYG{n}{type} \PYG{n}{is} \PYG{n+no}{NUMERIC}\PYG{p}{)} \PYG{o}{=\PYGZgt{}} \PYG{k}{return} \PYG{k+kp}{new} \PYG{n+no}{Numeric} \PYG{p}{(}\PYG{n}{stream}\PYG{o}{[}\PYG{l+m+mi}{0}\PYG{o}{].}\PYG{n}{string}\PYG{p}{)}
    \PYG{o}{|} \PYG{p}{(}\PYG{n}{stream}\PYG{o}{[}\PYG{l+m+mi}{0}\PYG{o}{].}\PYG{n}{type} \PYG{n}{is} \PYG{n+no}{IDENTIFIER}\PYG{p}{)} \PYG{o}{=\PYGZgt{}} \PYG{k}{return} \PYG{k+kp}{new} \PYG{n+no}{Symbol} \PYG{p}{(}\PYG{n}{stream}\PYG{o}{[}\PYG{l+m+mi}{0}\PYG{o}{].}\PYG{n}{string}\PYG{p}{)}
    \PYG{o}{|} \PYG{n}{otherwise} \PYG{o}{=\PYGZgt{}}
        \PYG{n+no}{Throw} \PYG{p}{(}\PYG{n+no}{UnknownTokenType}\PYG{p}{,}
          \PYG{l+s+s2}{\PYGZdq{}Token type\PYGZdq{}} \PYG{o}{++} \PYG{n}{stream}\PYG{o}{[}\PYG{l+m+mi}{0}\PYG{o}{].}\PYG{n}{type} \PYG{o}{++} \PYG{l+s+s2}{\PYGZdq{}is unknown.\PYGZdq{}}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} If our lexer was implemented properly, we wouldn\PYGZsq{}t have to throw}
        \PYG{c+c1}{\PYGZsh{} an error, so we\PYGZsq{}ll hopefully never reach the `Throw`.}
\end{Verbatim}
