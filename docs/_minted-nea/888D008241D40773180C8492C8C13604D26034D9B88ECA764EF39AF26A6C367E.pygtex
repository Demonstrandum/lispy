\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{evaluate} \PYG{o}{::} \PYG{p}{(}\PYG{n+no}{Call} \PYG{o}{|} \PYG{n+no}{Atomic}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+no}{Anything}
\PYG{n}{evaluate} \PYG{p}{(}\PYG{n}{node}\PYG{p}{)} \PYG{o}{=\PYGZgt{}}
  \PYG{k}{case} \PYG{n}{typeof}\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}
  \PYG{k}{when} \PYG{n+no}{Numeric} \PYG{o}{=\PYGZgt{}}
    \PYG{k}{return} \PYG{n}{literal\PYGZus{}eval} \PYG{p}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Doesn\PYGZsq{}t really get evaluated, per se,}
                                     \PYG{c+c1}{\PYGZsh{} as its really an \PYGZsq{}atomic\PYGZsq{} datum.}
  \PYG{k}{when} \PYG{n+nb}{String} \PYG{o}{=\PYGZgt{}}
    \PYG{k}{return} \PYG{n}{node} \PYG{c+c1}{\PYGZsh{} Already the most basic datatype.}
  \PYG{k}{when} \PYG{n+no}{Atom} \PYG{o}{=\PYGZgt{}}
    \PYG{c+c1}{\PYGZsh{} if the atom already exists in memory, just return it.}
    \PYG{k}{if} \PYG{n}{node}\PYG{o}{.}\PYG{n}{value} \PYG{n}{is} \PYG{k}{in} \PYG{n+no}{ATOMS\PYGZus{}HASHMAP} \PYG{o}{=\PYGZgt{}}
      \PYG{k}{return} \PYG{n+no}{ATOMS\PYGZus{}HASHMAP}\PYG{o}{[}\PYG{n}{node}\PYG{o}{.}\PYG{n}{value}\PYG{o}{]}
    \PYG{c+c1}{\PYGZsh{} Otherwise, add it to the hashmap, giving it a unique location}
    \PYG{c+c1}{\PYGZsh{}   in memory, which will be referenced whenever the same atom is}
    \PYG{c+c1}{\PYGZsh{}   used again.}
    \PYG{n+no}{ATOMS\PYGZus{}HASHMAP}\PYG{o}{[}\PYG{n}{node}\PYG{o}{.}\PYG{n}{value}\PYG{o}{]} \PYG{o}{=} \PYG{k+kp}{new} \PYG{n+no}{Atomise}\PYG{p}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n}{value}\PYG{p}{)}
    \PYG{k}{return} \PYG{n+no}{ATOMS\PYGZus{}HASHMAP}\PYG{o}{[}\PYG{n}{node}\PYG{o}{.}\PYG{n}{value}\PYG{o}{]}
  \PYG{k}{when} \PYG{n+no}{Symbol} \PYG{o}{=\PYGZgt{}}
    \PYG{k}{if} \PYG{n}{node}\PYG{o}{.}\PYG{n}{name} \PYG{n}{is} \PYG{k}{in} \PYG{n+no}{INTERNALS} \PYG{o}{=\PYGZgt{}}
      \PYG{k}{return} \PYG{n+no}{INTERNALS}\PYG{o}{[}\PYG{n}{node}\PYG{o}{.}\PYG{n}{name}\PYG{o}{]}
    \PYG{k}{return} \PYG{n}{lookup\PYGZus{}symbol} \PYG{p}{(}\PYG{n+no}{PARENT\PYGZus{}SCOPES}\PYG{p}{,} \PYG{n}{node}\PYG{o}{.}\PYG{n}{name}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}      \PYGZca{}\PYGZca{}\PYGZca{}\PYGZca{}\PYGZca{}\PYGZca{}\PYGZca{}\PYGZca{}\PYGZca{}\PYGZca{}\PYGZca{}\PYGZca{}\PYGZca{} Simple to implement, obvious what it does.}
  \PYG{k}{when} \PYG{n+no}{Call} \PYG{o}{=\PYGZgt{}}
    \PYG{n+nb}{caller} \PYG{o}{=} \PYG{n}{evaluate} \PYG{p}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n}{caller}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{typeof} \PYG{p}{(}\PYG{n+nb}{caller}\PYG{p}{)} \PYG{n}{is} \PYG{n+no}{FuncDef} \PYG{o}{=\PYGZgt{}}
      \PYG{k}{return} \PYG{n+nb}{caller}\PYG{o}{.}\PYG{n}{call} \PYG{p}{(}\PYG{n+nb}{caller}\PYG{o}{.}\PYG{n}{operands}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Make call to user defined function.}
    \PYG{k}{if} \PYG{n+nb}{caller} \PYG{n}{is} \PYG{n+no}{INTERNAL\PYGZus{}DEFINITION} \PYG{o}{=\PYGZgt{}}
      \PYG{k}{return} \PYG{n+nb}{caller} \PYG{p}{(}\PYG{n}{node}\PYG{p}{)}
    \PYG{k}{else} \PYG{o}{=\PYGZgt{}}
      \PYG{n+no}{Throw} \PYG{p}{(}\PYG{n+no}{UncallableCallerError}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}Can\PYGZsq{}t make call to this type...\PYGZdq{}}\PYG{p}{)}

  \PYG{n}{default} \PYG{o}{=\PYGZgt{}}
    \PYG{n+no}{Throw} \PYG{p}{(}\PYG{n+no}{UnknownTreeNode}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}I do not recognise the type of data you\PYGZsq{}ve}
\PYG{l+s+s2}{                             passed to be evaluated.\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}
